# 零钱兑换 II

例题：[leetcode 518 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/description/)

我们有一系列不同面额的硬币（无限使用），需要计算有多少种不同的组合方式可以凑出给定的总金额。这里的关键点是我们求的是**组合数**而非排列数，即{1,2,5}和{5,2,1}被视为同一种组合。

## 完全背包与组合数

这道题与普通完全背包问题的区别在于:

- 普通完全背包求的是"最大价值"
- 本题求的是"组合数量"

### 二维 DP 解法

在二维解法中，我们定义 `dp[i][j]`表示：使用前 i 种硬币（下标 0 到 i），凑成金额 j 的组合数。

#### 递推公式分析

对于每个硬币 `coins[i]`，我们有两种选择:

1. 不使用这个硬币，那么组合数就是 `dp[i-1][j]`
2. 使用这个硬币，那么组合数就是 `dp[i][j-coins[i]]`

所以递推公式为: `dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]]`

这个公式与 01 背包问题的区别在于，01 背包使用了 `dp[i-1][j-weights[i]]`，而完全背包使用 `dp[i][j-weights[i]]`，因为完全背包中每种物品可以重复使用。

#### 初始化考虑

- `dp[i][0] = 1`: 凑成金额 0 的方法只有一种，就是一个硬币都不选
- `dp[0][j] = j % coins[0] == 0 ? 1 : 0`: 只使用第一种硬币，只有当 `j 能被 coins[0]`整除时才有 1 种方法

### 一维 DP 优化

一维 `dp[j]`表示凑成金额 j 的组合数。

递推公式压缩为: `dp[j] += dp[j - coins[i]]`

这里有个重要的点：**遍历顺序决定了我们求的是组合数还是排列数**

- 外层遍历硬币，内层遍历金额：计算的是组合数
- 外层遍历金额，内层遍历硬币：计算的是排列数

对于本题，我们需要计算的是组合数，所以应该是:

```python
for coin in coins:          # 外层遍历硬币
    for j in range(coin, amount+1):  # 内层遍历金额
        dp[j] += dp[j - coin]
```

这样确保了{1,5}和{5,1}被视为同一种组合。

### 举例理解

以输入 `amount = 5, coins = [1, 2, 5]`为例:

1. 初始化 `dp[0] = 1`，其他为 0
2. 处理硬币 1:
   - `dp[1] = dp[0] = 1`
   - `dp[2] = dp[1] = 1`
   - `dp[3] = dp[2] = 1`
   - `dp[4] = dp[3] = 1`
   - `dp[5] = dp[4] = 1`
3. 处理硬币 2:
   - `dp[2] += dp[0] = 1+1 = 2`
   - `dp[3] += dp[1] = 1+1 = 2`
   - `dp[4] += dp[2] = 1+2 = 3`
   - `dp[5] += dp[3] = 1+2 = 3`
4. 处理硬币 5:
   - `dp[5] += dp[0] = 3+1 = 4`

最终 `dp[5] = 4`，表示有 4 种组合方式。

# 组合与排列的区别

首先明确基本概念：

- **组合**：不考虑元素顺序，例如 {1,5} 和 {5,1} 被视为同一种组合
- **排列**：考虑元素顺序，例如 {1,5} 和 {5,1} 被视为两种不同的排列

# 遍历顺序的影响

考虑 `amount = 3`, `coins = [1, 2]`，我们期望的组合有：

- 3 个 1: {1,1,1}
- 1 个 1 + 1 个 2: {1,2}

## 组合方式（外层遍历硬币）

1. 初始状态：`dp = [1, 0, 0, 0]`

2. 处理硬币 1：

   ```
   dp[1] += dp[0] = 0 + 1 = 1  （一个1）
   dp[2] += dp[1] = 0 + 1 = 1  （两个1）
   dp[3] += dp[2] = 0 + 1 = 1  （三个1）
   ```

   处理完硬币 1 后：`dp = [1, 1, 1, 1]`

3. 处理硬币 2：

   ```
   dp[2] += dp[0] = 1 + 1 = 2  （一个2）
   dp[3] += dp[1] = 1 + 1 = 2  （一个1和一个2）
   ```

   最终：`dp = [1, 1, 2, 2]`

结果中，`dp[3] = 2` 表示有两种组合方法。

## 排列方式（外层遍历金额）

1. 初始状态：`dp = [1, 0, 0, 0]`

2. 处理金额 1：

   ```
   考虑硬币1: dp[1] += dp[0] = 0 + 1 = 1
   考虑硬币2: (1 < 2，跳过)
   ```

   处理完金额 1 后：`dp = [1, 1, 0, 0]`

3. 处理金额 2：

   ```
   考虑硬币1: dp[2] += dp[1] = 0 + 1 = 1  （先放1，再递推）
   考虑硬币2: dp[2] += dp[0] = 1 + 1 = 2  （先放2，再递推）
   ```

   处理完金额 2 后：`dp = [1, 1, 2, 0]`

4. 处理金额 3：

   ```
   考虑硬币1: dp[3] += dp[2] = 0 + 2 = 2  （先放1，再递推，包含{1,1,1}和{1,2}）
   考虑硬币2: dp[3] += dp[1] = 2 + 1 = 3  （先放2，再递推，增加{2,1}）
   ```

   处理完金额 3 后：`dp = [1, 1, 2, 3]`

结果中，`dp[3] = 3` 表示有三种排列方法：{1,1,1}、{1,2}、{2,1}

**注意区别**：在排列计算中，{1,2}和{2,1}被视为不同的排列，所以得到的结果是 3 而不是 2。

# 为何如此？

这种差异是由遍历顺序决定的：

1. **外层遍历硬币（组合）**：

   - 我们先考虑硬币 1 的所有可能，再考虑硬币 2 的所有可能...
   - 这样就确保了硬币的使用顺序是固定的，只有"先加入硬币 1，再加入硬币 2..."这样的顺序
   - 因此，不会出现"先放 2 再放 1"和"先放 1 再放 2"被重复计算的情况

2. **外层遍历金额（排列）**：
   - x 对于每个金额 j，我们都会考虑所有硬币
   - 当我们考虑硬币 1 时，计算 `dp[j] += dp[j-1]`，这包含了"先放其他硬币，再放 1"的情况
   - 当我们考虑硬币 2 时，计算 `dp[j] += dp[j-2]`，这包含了"先放其他硬币，再放 2"的情况
   - 这样就会出现不同顺序的排列被分别计算的情况

# 二维解法

```cpp
class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        int n = coins.size();
        // 本题用int会溢出
        vector<vector<uint64_t>> dp(n, vector<uint64_t>(amount + 1));

        // 初始化dp
        // 1. amount = 0 时，凑成0元的情况只有一个都不选才行
        for (int i = 0; i < n; i++)
        {
            dp[i][0] = 1;
        }

        // 2. n=0时，仅使用第一个硬币的情况，只有amount是第一个硬币的倍数的时候才有一种方法
        for (int j = 0; j <= amount; j++)
        {
            if (j % coins[0] == 0)
            {
                dp[0][j] = 1;
            }
            else
            {
                dp[0][j] = 0;
            }
        }

        // dp 过程
        for (int i = 1; i < n; i++)
        {
            for (int j = 0; j <= amount; j++)
            {
                if (j < coins[i])
                {
                    dp[i][j] = dp[i - 1][j];
                }
                else
                {
                    // 本题是组合，不是求max
                    dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]];
                }
            }
        }

        return dp[n - 1][amount];
    }
};
```

# 一维解法

```cpp
class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        int n = coins.size();

        vector<uint64_t> dp(amount + 1, 0);

        dp[0] = 1; // 凑成0的组合数只有1种

        for (int i = 0; i < n; i++)
        {
            for (int j = coins[i]; j <= amount; j++)
            {
                dp[j] += dp[j - coins[i]];
            }
        }

        return dp[amount];
    }
};
```
