# 完全背包问题

完全背包和 01 背包问题唯一不同的地方就是，每种物品有无限件。

描述：有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是`weight[i]`，得到的价值是`value[i]` 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。

## 例子

背包最大重量为 4，物品有：

- 物品 0：重量 1，价值 5
- 物品 1：重量 3，价值 2
- 物品 2：重量 4，价值 3

## 动态规划五步法解析

### 1. 确定 dp 数组及含义

`dp[i][j]` 表示从下标为`[0-i]`的物品中选择，每个物品可以取无限次，放进容量为 j 的背包，能获得的最大价值总和。

### 2. 确定递推公式

对于完全背包问题，当考虑是否放入物品 i 时有两种选择：

- 不放物品 i：`dp[i-1][j]`
- 放物品 i：`dp[i][j-weight[i]] + value[i]`

注意这里与 01 背包的区别：当我们选择放入物品 i 时，因为物品数量无限，我们仍然可以继续考虑放入物品 i，所以是`dp[i][j-weight[i]]`而不是 01 背包中的`dp[i-1][j-weight[i]]`。

递推公式：`dp[i][j] = max(dp[i-1][j], dp[i][j-weight[i]] + value[i])`

### 3. dp 数组初始化

- 当背包容量 j 为 0 时，`dp[i][0] = 0`（无法放入任何物品）
- 对于物品 0，根据完全背包的特性：

  ```cpp
  for (int j = weight[0]; j <= bagWeight; j++) {
      dp[0][j] = dp[0][j - weight[0]] + value[0];
  }
  ```

这表示能放多少个物品 0 就放多少个，因为物品 0 可以无限次选择。

初始化完成后的部分 dp 数组（以示例数据为例）：

- `dp[0][0] = 0`
- `dp[0][1] = 5`（放入一个物品 0）
- `dp[0][2] = 10`（放入两个物品 0）
- `dp[0][3] = 15`（放入三个物品 0）
- `dp[0][4] = 20`（放入四个物品 0）

### 4. 确定遍历顺序

二维 dp 数组的完全背包问题中，物品和背包的遍历顺序都可以，因为所需的值在二维数组中都已经计算好了。

可以先遍历物品，再遍历背包：

```cpp
for (int i = 1; i < n; i++) { // 遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
        if (j < weight[i])
            dp[i][j] = dp[i - 1][j];
        else
            dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);
    }
}
```

也可以先遍历背包，再遍历物品：

```cpp
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for (int i = 1; i < n; i++) { // 遍历物品
        if (j < weight[i])
            dp[i][j] = dp[i - 1][j];
        else
            dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);
    }
}
```

### 5. 举例推导 dp 数组

以我们的示例数据，完整填充 dp 数组的过程：

物品 0 已在初始化时处理，接下来处理物品 1（重量 3，价值 2）：

- `dp[1][0] = 0`（容量为 0，不能放物品）
- `dp[1][1] = dp[0][1] = 5`（不能放下物品 1，所以沿用`dp[0][1]`的值）
- `dp[1][2] = dp[0][2] = 10`（不能放下物品 1）
- `dp[1][3] = max(dp[0][3], dp[1][0] + 2) = max(15, 0+2) = 15`（放物品 1 不如放 3 个物品 0）
- `dp[1][4] = max(dp[0][4], dp[1][1] + 2) = max(20, 5+2) = 20`（放物品 1 不如放 4 个物品 0）

处理物品 2（重量 4，价值 3）：

- `dp[2][0] = 0`
- `dp[2][1] = dp[1][1] = 5`
- `dp[2][2] = dp[1][2] = 10`
- `dp[2][3] = dp[1][3] = 15`
- `dp[2][4] = max(dp[1][4], dp[2][0] + 3) = max(20, 0+3) = 20`（放物品 2 不如之前的策略）

最终答案是 `dp[2][4] = 20`，即背包容量为 4 时能获得的最大价值是 20。

# 题目

[卡码网 52 携带研究材料](https://kamacoder.com/problempage.php?pid=1052)

```cpp
#include<bits/stdc++.h>

using namespace std;

int main(){
    // n种材料，最大容量为v
    int n, v;
    cin >> n >> v;

    vector<int> weight(n, 0);
    vector<int> value(n, 0);
    for(int i = 0; i < n; i ++){
        cin >> weight[i] >> value[i];
    }

    vector<vector<int>> dp(n, vector<int>(v + 1, 0));

    // dp初始化：物品0能放几个就放几个
    for(int j = weight[0]; j <= v; j ++){
        dp[0][j] = dp[0][j - weight[0]] + value[0];
    }

    // dp过程
    for(int i = 1; i < n; i ++){
        for(int j = 0; j <= v; j ++){
            if(j < weight[i]){
                dp[i][j] = dp[i - 1][j]; // 放不下物品i
            }else{
                dp[i][j] = max(dp[i-1][j], dp[i][j - weight[i]] + value[i]);
            }
        }
    }

    cout << dp[n-1][v];

    return 0;
}
```

# 将上述方法压缩到一维

完全背包问题也可以使用一维 DP 数组来实现，这样可以节省空间复杂度。从二维 DP 转化为一维 DP 的思路与 01 背包类似，但有一些关键区别。

## 从二维 DP 转为一维 DP 的思路

回顾完全背包的二维 DP 递推公式：

```
dp[i][j] = max(dp[i-1][j], dp[i][j-weight[i]] + value[i])
```

当我们将二维压缩为一维时，实际上是把"上一层"的状态拷贝到"当前层"。这样递推公式变为：

```
dp[j] = max(dp[j], dp[j-weight[i]] + value[i])
```

这个递推公式看起来与 01 背包的一维公式完全相同，但遍历顺序有重要差异。

## 遍历顺序的关键区别

在 01 背包的一维实现中，必须**从后向前**遍历背包容量，这是为了确保每个物品只被使用一次。

而在完全背包中，由于每个物品可以使用无限次，我们需要**从前向后**遍历背包容量，这样才能在一次遍历中考虑到同一物品的多次使用情况。

从前向后遍历背包容量时：

```
dp[j] 依赖于 dp[j-weight[i]]
```

当我们计算 `dp[j]`时，`dp[j-weight[i]]`已经在本轮被更新过，可能已经包含了物品 i 的价值，这正是我们在完全背包中想要的效果。

## 代码实现的两种方式

完全背包问题在一维 DP 实现中，物品和背包容量的遍历顺序是可以互换的，这与 01 背包不同。

### 方式一：先遍历背包容量，再遍历物品

```c++
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0)
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

### 方式二：先遍历物品，再遍历背包容量

```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

这两种方式都是可以的，因为在完全背包问题中，我们总是从小到大遍历背包容量，确保了 `dp[j-weight[i]]`已经是考虑了当前物品 i 的情况。

## 01 背包与完全背包的一维 DP 区别总结

两个问题在一维 DP 实现中的主要区别：

1. **遍历顺序**：

   - 01 背包：背包容量必须从大到小遍历（倒序）
   - 完全背包：背包容量从小到大遍历（正序）

2. **原因**：

   - 01 背包倒序遍历是为了确保每个物品只被使用一次
   - 完全背包正序遍历是为了允许物品被多次使用

3. **两层循环顺序**：
   - 01 背包：必须先遍历物品，再遍历背包容量
   - 完全背包：物品和背包的遍历顺序可以互换

# 例题的一维解法：

```cpp
#include<bits/stdc++.h>

using namespace std;

int main(){
    // n种材料，最大容量为v
    int n, v;
    cin >> n >> v;

    vector<int> weight(n, 0);
    vector<int> value(n, 0);
    for(int i = 0; i < n; i ++){
        cin >> weight[i] >> value[i];
    }

    vector<int> dp(v + 1, 0);

    for(int i = 0; i < n; i ++){
        for(int j = weight[i]; j <= v; j ++){
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }

    cout << dp[v];
    return 0;
}
```
