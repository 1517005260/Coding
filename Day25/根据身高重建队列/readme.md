# 根据身高重建队列

例题：[leetcode 406 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/description/)

同[分发糖果](../分发糖果/)，这里是两个维度的考虑，需要我们分两步走，否则会顾此失彼。

按题意，矮子是不会影响高子的，所以我们优先考虑高的，在相同身高内部，按 k 升序排列，因为 k 大的要排在后面。

得到有序序列后，我们就可以遍历数组，把`[h,k]`插入第 k 个位置，这样前面就有 k 个人比他高了。

```cpp
class Solution
{
public:
    static bool cmp(vector<int> &a, vector<int> &b)
    {
        if (a[0] == b[0])
        {
            // 身高相同，按k升序
            return a[1] < b[1];
        }
        else
        {
            // 按身高降序
            return a[0] > b[0];
        }
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>> &people)
    {
        sort(people.begin(), people.end(), cmp);

        vector<vector<int>> res;
        for (vector<int> p : people)
        {
            res.insert(res.begin() + p[1], p);
        }

        return res;
    }
};
```

插入过程模拟：

输入：`[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]`

1. 排序后：`[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]`（身高降序，同身高 k 值升序）

2. 插入过程：

   - 插入[7,0]：结果 = `[[7,0]]`（插入到第 0 位）
   - 插入[7,1]：结果 = `[[7,0], [7,1]]`（插入到第 1 位）
   - 插入[6,1]：结果 = `[[7,0], [6,1], [7,1]]`（插入到第 1 位）
   - 插入[5,0]：结果 = `[[5,0], [7,0], [6,1], [7,1]]`（插入到第 0 位）
   - 插入[5,2]：结果 = `[[5,0], [7,0], [5,2], [6,1], [7,1]]`（插入到第 2 位）
   - 插入[4,4]：结果 = `[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]`（插入到第 4 位）

3. 最终结果：`[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]`
