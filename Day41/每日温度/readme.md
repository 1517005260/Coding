# 每日温度

例题：[leetcode 739 每日温度](https://leetcode.cn/problems/daily-temperatures/description/)

## 暴力解法

按题意模拟即可，这种办法超时了，测试数据过了`46/48`：

```cpp
class Solution
{
public:
    vector<int> dailyTemperatures(vector<int> &temperatures)
    {
        vector<int> res(temperatures.size(), 0);

        for (int i = 0; i < temperatures.size(); i++)
        {
            for (int j = i + 1; j < temperatures.size(); j++)
            {
                if (temperatures[j] > temperatures[i])
                {
                    res[i] = j - i; // j-i天后
                    break;
                }
            }
        }
        return res;
    }
};
```

## 单调栈方法

通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。时间复杂度为 O(n)。

用一个栈来记录我们遍历过的元素，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。

### 单调栈的基本思想

1. **空间换时间**：用一个栈记录遍历过程中还未找到右侧更高温度的下标。
2. **单调性**：本题要求找“右侧第一个更高的温度”，因此我们构造一个**递增的栈**（注意这里是从栈顶到栈底保持递增关系）。
   - 这样，当遇到一个新的温度时，如果它比栈顶的温度高，就说明新温度就是栈顶对应温度的第一个更高温度，可以直接计算出相隔的天数。
3. **下标而非温度**：栈中只存储下标，通过下标可以直接访问温度数组，这样在更新结果时很方便。

## 单调栈的操作流程

设温度数组为 `T`，初始化一个结果数组 `result`（所有元素初始为 0），同时使用一个空栈来保存下标。

遍历数组的每个下标 `i`：

1. **当栈不为空且当前温度 T[i] 大于栈顶下标对应的温度 T[st.top()]**：
   - 说明 T[i] 就是栈顶元素右边第一个更高的温度。
   - 更新 `result[st.top()] = i - st.top()`（即等待的天数）。
   - 弹出栈顶元素。
   - **重复**上述操作，直到栈为空或当前温度不再大于栈顶温度。
2. **否则**（包括当前温度小于或等于栈顶温度）：
   - 直接将下标 `i` 压入栈中。

注意：当温度相等时，由于题目要求找的是**严格大于**的温度，我们依然把该下标压入栈，等待后续找到更高的温度来处理。

遍历结束后，栈中剩下的下标对应的温度右侧都没有更高的温度，`result` 中这些位置保持为 0。

## 示例演示

以 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]` 为例，逐步讲解单调栈的过程：

1. **初始**：
   - 栈为空
   - 将第 0 个下标 `0`（温度 73）压入栈中。
   - 栈状态：`[0]`
2. **i = 1, T[1] = 74**：
   - 比较 74 和栈顶对应的 T[0] = 73
   - 74 > 73，说明 T[1] 是 T[0] 的右侧第一个更高温度
   - 更新 `result[0] = 1 - 0 = 1`，弹出 0
   - 压入 1
   - 栈状态：`[1]`
3. **i = 2, T[2] = 75**：
   - 比较 75 与 T[1] = 74
   - 75 > 74，更新 `result[1] = 2 - 1 = 1`，弹出 1
   - 压入 2
   - 栈状态：`[2]`
4. **i = 3, T[3] = 71**：
   - 71 < T[2] = 75，直接压入 3
   - 栈状态：`[2, 3]`
5. **i = 4, T[4] = 69**：
   - 69 < 栈顶 T[3] = 71，直接压入 4
   - 栈状态：`[2, 3, 4]`
6. **i = 5, T[5] = 72**：
   - 72 > T[4] = 69
     - 更新 `result[4] = 5 - 4 = 1`，弹出 4
   - 继续比较 72 与新的栈顶 T[3] = 71
     - 72 > 71
     - 更新 `result[3] = 5 - 3 = 2`，弹出 3
   - 此时栈顶为 T[2] = 75，72 < 75，不再弹出
   - 压入 5
   - 栈状态：`[2, 5]`
7. **i = 6, T[6] = 76**：
   - 76 > T[5] = 72
     - 更新 `result[5] = 6 - 5 = 1`，弹出 5
   - 继续比较 76 与新的栈顶 T[2] = 75
     - 76 > 75
     - 更新 `result[2] = 6 - 2 = 4`，弹出 2
   - 栈为空，压入 6
   - 栈状态：`[6]`
8. **i = 7, T[7] = 73**：
   - 73 < T[6] = 76，直接压入 7
   - 栈状态：`[6, 7]`

遍历结束后，栈中剩下的下标（6 和 7）没有找到右侧更高温度，因此 `result[6]` 和 `result[7]` 保持为 0。

最终结果为：[1, 1, 4, 2, 1, 1, 0, 0]。

```cpp
class Solution
{
public:
    vector<int> dailyTemperatures(vector<int> &temperatures)
    {
        vector<int> res(temperatures.size(), 0);

        stack<int> s;

        for (int i = 0; i < temperatures.size(); i++)
        {
            // 如果栈非空，且栈顶下标对应的温度，小于右边新来的，满足条件
            while (!s.empty() && temperatures[s.top()] < temperatures[i])
            {
                int idx = s.top();
                s.pop();
                res[idx] = i - idx;
            }

            s.push(i);
        }

        return res;
    }
};
```
