# 整数拆分

例题：[leetcode 343 整数拆分](https://leetcode.cn/problems/integer-break/description/)

1. `dp[i]`表示，将数字 i 拆分后，获得的最大乘积是`dp[i]`

2. 递推公式：

对于任意一个整数`i`，我们有以下思考过程：

- 我们需要把`i`至少拆成两部分
- 假设我们拆出第一个数是`j`（其中`1 ≤ j < i`），那么剩下的部分就是`i-j`
- 对于剩下的`i-j`，我们有两种选择：

  - 选择 1：**不再继续拆分**`i-j`，直接使用`j × (i-j)`作为乘积
  - 选择 2：**继续拆分**`i-j`，使用`j × dp[i-j]`作为乘积（因为`dp[i-j]`已经表示了`i-j`拆分后的最大乘积）

- 我们需要在所有可能的`j`值（从 1 到 i-1）中，找出能使乘积最大的那个

所以状态转移方程是：

```
dp[i] = max( max(j × (i-j), j × dp[i-j]) )，其中j从1到i-1
```

**具体例子演示**

让我们以`n = 4`为例，详细演示转移方程的应用过程：

首先，初始条件：

- `dp[1] = 0`（因为 1 不能再拆分）
- `dp[2] = 1`（拆分为 1+1，乘积为 1×1=1）

现在计算`dp[3]`：

- j = 1 时：
  - 选择 1：1 × (3-1) = 1 × 2 = 2
  - 选择 2：1 × dp[2] = 1 × 1 = 1
  - 取最大值：max(2, 1) = 2
- j = 2 时：
  - 选择 1：2 × (3-2) = 2 × 1 = 2
  - 选择 2：2 × dp[1] = 2 × 0 = 0
  - 取最大值：max(2, 0) = 2
- 在所有 j 值中取最大：max(2, 2) = 2
  所以`dp[3] = 2`

接下来计算`dp[4]`：

- j = 1 时：
  - 选择 1：1 × (4-1) = 1 × 3 = 3
  - 选择 2：1 × dp[3] = 1 × 2 = 2
  - 取最大值：max(3, 2) = 3
- j = 2 时：
  - 选择 1：2 × (4-2) = 2 × 2 = 4
  - 选择 2：2 × dp[2] = 2 × 1 = 2
  - 取最大值：max(4, 2) = 4
- j = 3 时：
  - 选择 1：3 × (4-3) = 3 × 1 = 3
  - 选择 2：3 × dp[1] = 3 × 0 = 0
  - 取最大值：max(3, 0) = 3
- 在所有 j 值中取最大：max(3, 4, 3) = 4
  所以`dp[4] = 4`

**为什么不拆分 j？**：因为在动态规划中，我们假设已经计算过的子问题都是最优解。

3. 初始条件，在 2 中已经讲过

4. 从前往后枚举 i 和拆分的 j

```cpp
class Solution
{
public:
    int integerBreak(int n)
    {
        vector<int> dp(n + 1, 0);
        dp[1] = 0;
        dp[2] = 1;

        for (int i = 3; i <= n; i++)
        {
            for (int j = 1; j < i; j++)
            {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }

        return dp[n];
    }
};
```
