# 不同的子序列

例题：[leetcode 115 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/description/)

动态规划解法需要按照[判断子序列](../../Day38/判断子序列/)的方式，只不过上道题是要判断是否存在子序列，本题是要求子序列存在多少个：

1. `dp[i][j]`表示：

以`s[i-1]`结尾的序列中，有多少以`t[j-1]`结尾的子序列

2. 递推公式

需要考虑两种情况：

**情况 1: `s[i-1] == t[j-1]`**
当当前字符相等时，有两种选择：

- 使用 `s[i-1]`匹配 `t[j-1]`：此时使用`dp[i-1][j-1]`的结果
- 不使用 `s[i-1]`匹配：此时相当于删除 `s[i-1]`，结果为`dp[i-1][j]`

举例说明为什么要考虑"不使用 `s[i-1]`"的情况：

比如 s="bagg", t="bag"，当我们考虑最后一个字符时，虽然 g==g，但我们可以选择不用 s 中的最后一个 g 来匹配，而是用前面的字符来匹配，即要么选定最后一个 g，在前面匹配`ba`，要么不选最后一个 g，在前面匹配`bag`。

因此，当 `s[i-1] == t[j-1]`时，`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`

**情况 2: `s[i-1] != t[j-1]`**
当当前字符不相等时，我们只能选择忽略 `s[i-1]`，也就是：`dp[i][j] = dp[i-1][j]`

3. 初始化 dp 数组

根据递推公式，我们需要初始化 `dp[i][0]`和 `dp[0][j]`：

- `dp[i][0]`表示：s 的前 i 个字符要组成空字符串 t 的个数。显然，空串是所有字符串的子串，所以`dp[i][0] = 1`。

- `dp[0][j]`表示：空字符串 s 要组成 t 的前 j 个字符的个数。显然，任何非空串都不是空串的子序列，所以`dp[0][j] = 0`。

- 特殊情况：`dp[0][0] = 1`，表示空字符串 s 可以组成空字符串 t，且只有一种方式。

4. 确定遍历顺序：i，j 顺序遍历即可

```cpp
class Solution
{
public:
    int numDistinct(string s, string t)
    {
        int m = s.size(), n = t.size();

        vector<vector<uint64_t>> dp(m + 1, vector<uint64_t>(n + 1, 0));

        // 初始化
        for (int i = 0; i <= m; i++)
        {
            dp[i][0] = 1;
        }

        // dp
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                // 如果当前字符相等
                // 要么用当前字符匹配，要么不用当前字符匹配
                if (s[i - 1] == t[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                }
                else
                {
                    // 当前字符串不相等
                    // 只能用s前面的部分进行匹配
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        return dp[m][n];
    }
};
```
