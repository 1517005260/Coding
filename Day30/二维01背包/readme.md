# 01 背包问题 二维

## 问题定义

- 有 n 件物品和一个最大承重为 w 的背包
- 每件物品的重量是 `weight[i]`，价值是 `value[i]`
- 每件物品只能用一次
- 目标：找出装入背包的物品组合，使总价值最大

## 暴力解法

- 每件物品有两个状态：取或不取
- 回溯法搜索所有情况，时间复杂度 `O(2^n)`
- 由于指数级复杂度，需要动态规划进行优化

## 动态规划解法

### 1. 确定 dp 数组及含义

- 二维数组 `dp[i][j]`
  - i：表示考虑`[0-i]`范围内的物品
  - j：表示背包容量
  - `dp[i][j]`：表示从下标为`[0-i]`的物品中任意取，放入容量为 j 的背包，能获得的最大价值

### 2. 确定递推公式

对于每个物品 i 和背包容量 j，有两种选择：

- 不放物品 i：`dp[i][j] = dp[i-1][j]`
- 放物品 i：`dp[i][j] = dp[i-1][j-weight[i]] + value[i]`（前提是 j ≥ `weight[i]`）

综合得到递推公式：

```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])  如果j ≥ weight[i]
dp[i][j] = dp[i-1][j]  如果j < weight[i]
```

#### 详细解释

递推公式的核心思想：对于每个物品 i 和背包容量 j，我们面临一个决策：**是否将这个物品放入背包**。这个决策会导致两种不同的状态转移路径。

##### 两种选择

1. **不放入物品 i**：

   - 如果我们决定不把物品 i 放入背包，那么背包内的物品仍然是来自于前 i-1 个物品
   - 此时的最大价值就是：`dp[i-1][j]`
   - 含义：考虑 0 到 i-1 的物品，在容量为 j 的背包下能获得的最大价值

2. **放入物品 i**：
   - 如果我们决定把物品 i 放入背包，首先背包必须有足够的容量（即 j ≥ `weight[i]`）
   - 放入物品 i 后，我们获得了 `value[i]`的价值
   - 但背包容量减少了 `weight[i]`
   - 剩余容量是 `j-weight[i]`
   - 在这个剩余容量下，我们还可以从前 i-1 个物品中选择物品放入背包
   - 所以这种情况下的最大价值是：`dp[i-1][j-weight[i]] + value[i]`
   - 含义：考虑 0 到 i-1 的物品，在容量为 `j-weight[i]`的背包下能获得的最大价值，再加上物品 i 的价值

#### 实例解析

我们用例子来理解：

- 物品 0：重量 1，价值 15
- 物品 1：重量 3，价值 20
- 物品 2：重量 4，价值 30
- 背包容量：4

计算 `dp[1][4]`（考虑物品 0 和物品 1，背包容量为 4）：

- 选择 1（不放物品 1）：`dp[0][4] = 15`
  （仅考虑物品 0，背包容量 4 的最大价值是 15）

- 选择 2（放物品 1）：`dp[0][4-3] + 20 = dp[0][1] + 20`
  （放入物品 1 后，剩余容量为 1，在这个容量下考虑物品 0 的最大价值是 15，再加上物品 1 的价值 20）
  = 15 + 20 = 35

因为 35 > 15，所以我们选择放入物品 1，`dp[1][4] = 35`。

再计算 `dp[2][4]`（考虑物品 0、1 和 2，背包容量为 4）：

- 选择 1（不放物品 2）：`dp[1][4] = 35`
  （考虑物品 0 和 1，背包容量 4 的最大价值是 35）

- 选择 2（放物品 2）：`dp[1][4-4] + 30 = dp[1][0] + 30`
  （放入物品 2 后，剩余容量为 0，在这个容量下考虑物品 0 和 1 的最大价值是 0，再加上物品 2 的价值 30）
  = 0 + 30 = 30

因为 35 > 30，所以我们选择不放入物品 2，`dp[2][4] = 35`。

所以最终的最大价值是 35，对应的选择是放入物品 0 和物品 1。

### 3. dp 数组初始化

初始化要遵循 dp 数组的定义：`dp[i][j]` 表示从下标为`[0-i]`的物品里任意取，放进容量为 j 的背包，价值总和最大是多少。

#### 第一种情况：背包容量为 0

当背包容量 j 为 0 时，无论选择哪些物品，都无法放入背包，因此最大价值必然为 0。

```
dp[i][0] = 0 (对所有的i从0到n-1)
```

#### 第二种情况：只考虑物品 0

当我们只考虑第一个物品（物品 0）时：

- 如果背包容量小于物品 0 的重量（j < `weight[0]`），则放不下物品 0，最大价值为 0
- 如果背包容量大于等于物品 0 的重量（j ≥ `weight[0]`），则可以放下物品 0，最大价值为 `value[0]`

```
dp[0][j] = 0 (当j < weight[0])
dp[0][j] = value[0] (当j ≥ weight[0])
```

### 4. 确定遍历顺序

两种遍历顺序都可行：

1. 先遍历物品，再遍历背包容量（更易理解）

```
for i = 1 to n-1:
    for j = 0 to W:
        if j < weight[i]:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])
```

2. 先遍历背包容量，再遍历物品

```
for j = 0 to W:
    for i = 1 to n-1:
        if j < weight[i]:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])
```

### 5. 完整实现代码

```cpp
vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));
// 初始化第一行
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}

// 填充dp表
for (int i = 1; i < weight.size(); i++) {
    for (int j = 0; j <= bagweight; j++) {
        if (j < weight[i]) {
            dp[i][j] = dp[i-1][j];  // 放不下物品i
        } else {
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);
        }
    }
}

// 最终结果
return dp[weight.size()-1][bagweight];
```

# 例题

[卡码网 46 携带研究材料（第六期模拟笔试）](https://kamacoder.com/problempage.php?pid=1046)

```cpp
// 答案应该是dp[m-1][n]
#include<bits/stdc++.h> // 引入万能头文件，这样就不用记需要导入哪些头文件了

using namespace std;

int main(){
    int m, n;
    cin >> m;
    cin >> n;

    vector<int> space(m,0);
    vector<int> value(m,0);

    for(int i = 0; i < m; i++){
        cin >> space[i];
    }

    for(int i=0; i < m; i++){
        cin >> value[i];
    }

    // 背包最大容量为 n, 所以空间要开到 n + 1
    vector<vector<int>> dp(m, vector<int>(n + 1, 0));

    // dp数组初始化
    // 1. 容量为空的时候，dp为空
    for(int i = 0; i < m; i++){
        dp[i][0] = 0;
    }

    // 2. 装入物品0时
    for(int j = space[0]; j <= n; j++){
        dp[0][j] = value[0];
    }

    // 开始遍历
    // i = 0 已被初始化
    for(int i = 1; i < m; i++){
        for(int j = 0; j <= n; j ++){
            if(j < space[i]){
                dp[i][j] = dp[i-1][j];
            }else{
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-space[i]] + value[i]);
            }
        }
    }

    cout << dp[m-1][n];
}
```
