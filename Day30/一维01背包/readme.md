# 01 背包问题 一维

在刚刚[二维](../二维01背包/)的基础上，使用**滚动数组**将二维的空间优化为一维

## 为什么要使用一维数组（滚动数组）

在二维 DP 解法中，我们使用`dp[i][j]`表示从前 i 个物品中选择，放入容量为 j 的背包能获得的最大价值。观察递推公式：

`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])`

我们可以发现一个重要特点：**计算第 i 行时，只需要第 i-1 行的信息**。这意味着我们不需要保存所有历史数据，只需要保存上一行的结果即可。

进一步思考，我们可以直接用一个一维数组`dp[j]`来代替二维数组，其中`dp[j]`表示容量为 j 的背包能装的最大价值。每次更新这个数组时，我们相当于是把上一行的结果直接覆盖到当前行。

## 一维 DP 解法的五个步骤

### 1. 确定 dp 数组含义

`dp[j]`：容量为 j 的背包能装的最大价值

### 2. 确定递推公式

从二维公式简化而来：`dp[j] = max(dp[j], dp[j-weight[i]] + value[i])`

这里`dp[j]`代表不选当前物品 i 的最大价值（对应二维中的`dp[i-1][j]`），而`dp[j-weight[i]] + value[i]`代表选择当前物品 i 的最大价值。

### 3. 初始化

由于`dp[j]`表示容量为 j 的背包的最大价值，所以：

- `dp[0] = 0`（容量为 0 的背包无法装物品，价值为 0）
- 其他位置初始化为 0（如果物品价值均为正数，初始化为 0 不会影响取最大值）

### 4. 遍历顺序（重点！）

这是一维 DP 最关键的部分，有两个重要区别：

**1 背包容量必须逆序遍历**

```cpp
for (int j = bagWeight; j >= weight[i]; j--)
```

为什么必须逆序？因为正序遍历会导致物品被重复使用。例如：

- 物品 0 重量为 1，价值为 15
- 如果正序遍历：

  - 先计算`dp[1] = dp[0] + 15 = 15`
  - 再计算`dp[2] = dp[1] + 15 = 30`（这里用到了更新后的 dp[1]，相当于物品 0 被使用了两次！）

- 如果逆序遍历：
  - 先计算`dp[2] = dp[1] + 15 = 15`
  - 再计算`dp[1] = dp[0] + 15 = 15`
  - 这样保证了物品 0 只被使用一次

**2 必须先遍历物品，再遍历背包容量**

```cpp
for (物品)
    for (容量-逆序)
```

如果先遍历背包容量，再遍历物品，由于每个容量只会被更新一次，相当于每个背包只放入一个物品，这明显不是我们想要的结果。

## 与二维 DP 的主要区别

1. **数组定义**:

   - 二维：`dp[i][j]`表示从前 i 个物品中选择，放入容量为 j 的背包能获得的最大价值
   - 一维：`dp[j]`表示容量为 j 的背包能装的最大价值

2. **遍历顺序**:

   - 二维：物品和背包容量的遍历顺序均可以是正序
   - 一维：物品正序遍历，但背包容量必须逆序遍历

3. **空间复杂度**:
   - 二维：O(物品数量 × 背包容量)
   - 一维：O(背包容量)

这种用一维数组代替二维数组的技术叫做"滚动数组"，它可以显著减少空间复杂度，是解决背包问题常用的优化手段。理解一维 DP 的关键在于掌握遍历顺序：物品外层，背包容量内层且逆序遍历。

# 例题

[卡码网 46 携带研究材料（第六期模拟笔试）](https://kamacoder.com/problempage.php?pid=1046)

```cpp
#include<bits/stdc++.h>

using namespace std;

int main(){
    int m, n;
    cin >> m;
    cin >> n;

    vector<int> space(m, 0);
    vector<int> value(m, 0);

    for(int i = 0; i < m; i ++){
        cin >> space[i];
    }

    for(int i = 0; i < m; i ++){
        cin >> value[i];
    }

    // 一维dp数组
    vector<int> dp(n + 1, 0);
    // 一维dp数组全0初始化即可

    // 一维dp数组仍需要双重循环遍历
    for(int i = 0; i < m; i ++){
        for(int j = n; j >= space[i]; j --){
            dp[j] = max(dp[j], dp[j-space[i]] + value[i]);
        }
    }

    cout << dp[n];
}
```

两种方法的空间复杂度对比：

![对比](./对比.png)
